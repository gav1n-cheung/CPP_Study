## 对象特性

### 对象的初始化和清理
C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置

#### 构造函数和析构函数概述

对象的初始化和清理也是两个非常重要的安全问题：
* 一个对象或者变量没有初始状态，对其使用后果是未知的
* 同样的是用完一个对象或者变量，没有及时清理，也会造成一定的安全问题  

C++使用构造函数和析构函数解决上述问题，这两个函数将被编译器自动调用，完成对象初始化和清理工作
对象的初始化和清理工作是编译器强制要求我们要做的事，如果我们不提供构造和析构函数，编译器会提供（编译器提供的构造函数和析构函数是空实现）

* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
* 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作
  
构造函数语法：类名(){}
* 构造函数没有返回值也不写void
* 函数名称与类名相同
* 构造函数不可以有参数，因此不可以发生重载
* 程序在调用对象时会自动调用构造函数，无需手动调用，而且只会调用一次

构造函数语法：~类名(){}
* 析构函数：没有返回值也不写void
* 函数名称与类名相同，在名称前加上符号~
* 析构函数不可有参数，因此不可以发生重载
* 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次
  
#### 构造函数的分类以及调用
构造函数的分类及调用
* 按参数分类：有参构造和无参构造（默认构造）
* 按类型分类：普通构造和拷贝构造

三种调用方法：
* 括号法
* 显示法
* 隐式转换法
```
括号法：
Person p;//调用默认（无参）构造函数
Person p2(10);//调用有参构造函数
Person p3(p2);//调用拷贝构造函数

需要注意的是：在调用默认构造函数时，不要添加()，否则会被编译器认为是在声明函数
```
```
显示法：
Person p5;//调用默认（无参）构造函数
Person p6=Person(10);//调用有参构造函数
Person p7=Person(p6);//调用拷贝构造函数
Person(10);//匿名对象，当前行结束后，系统会立即回收掉匿名对象，对该行调用有参构造函数后，就立即析构掉该对象了

需要注意的是：不要利用拷贝构造函数来初始化一个匿名对象，编译器会认为Person(p6)=====Person p6,调用的其实是默认构造函数，造成了p6的重定义
```
```
隐式转换法
Person p8=10;//调用有参构造函数
Person p9=p8;//拷贝构造
```

##### 拷贝构造函数使用时机：
* 使用一个已经创建完毕的对象来初始化一个新对象
* 值传递方式给函数参数传值
* 以值方式返回局部对象

```
使用一个创建完毕的对象来初始化一个新对象
Person p1;
Person p2(p2);
```
```
值传递方式给函数参数传值
void doWork(Person p){
    p.age=100;
}
Person p1;
doWork(p1);//通过值传递的方式给函数参数传值
cout<<"";
执行顺序:
默认构造函数->拷贝构造函数->拷贝析构函数->cout；
这种方式类似于形参，创建在栈区的拷贝构造函数在函数执行完毕后就被销毁了(cout之前调用了析构函数)  
当然的该拷贝构造对象也没有对原来的默认构造对象产生影响，p1.age仍然等于默认值
```
```
值方式返回局部对象
Person doWork2(){
    Person p1(10);
    cout<<&p1<<endl;
    return p1;
}

Person p1;
cout<<&p1<<endl;
p1.doWork2();
cout<<&p1<<endl;
cout<<p1.age<<endl;

看前面这一段代码，首先创建了一个默认构造函数构造的对象，输出其地址为0x7ffdbbd22a70  
然后调用doWork2()函数,在函数内创建一个有参构造函数构造的有参对象,这个对象毫无疑问在栈区,在函数执行完毕后该对象就被销毁,输出该对象的地址为0x7ffdbbd22a74  
执行完毕函数完毕后,再输出main中的p1对象地址,仍然为0x7ffdbbd22a70,但是输出其属性age为doWork2中局部对象的age值  
总的来说,doWork2创建的局部对象虽然销毁了,但是其值却返回给了main中的对象了,使得p1的值发生了变化,但是其地址并没有发生变化,就是说执行了一个赋值的操作,而doWork2也就是使用值方式来返回了局部对象
```
```
再来看这段代码
Person p1=doWork2();
cout<<&p1<<endl;
此时doWork2中的p1地址为0x7ffe57e85e14,而在main中输出的p1地址也为0x7ffe57e85e14,也就是将局部变量的地址值给到了p1,  
这个过程中并没有调用拷贝构造函数,是否是直接等于创建了一个有参对象呢?
```

##### 构造函数调用规则
默认情况下:C++编译器至少给一个类添加3个参数
* 默认构造函数(无参,函数体为空)
* 默认析构函数(无参,函数体为空)
* 默认拷贝构造函数(对属性进行值拷贝)
  
构造函数调用规则如下:
* 如果用户定义有参构造函数,则C++不会再提供默认无参构造,但是会提供默认拷贝构造
* 如果用户定义有拷贝构造函数,则C++不会再提供其他的构造函数

##### C++初始化列表
作用:
C++提供了初始化参数列表语法,用于初始化属性
```
语法:构造函数():属性1(值1),属性2(值2),.....{}
```


#### 浅拷贝和深拷贝
浅拷贝:简单地进行赋值拷贝操作
深拷贝:在堆区重新申请空间,进行拷贝操作
如果属性有在堆区开辟的,一定要自己提供拷贝构造函数,防止浅拷贝带来的问题

```
class Person {
public:
    Person() {
        std::cout << "默认构造函数" << std::endl;
    }

    Person(int age, int height) {
        m_height = new int(height);
        m_age = age;
        std::cout << "有参构造函数" << std::endl;
    }

    //自己写一个拷贝构造函数来解决浅拷贝带来的堆区内存重复释放问题
    Person(const Person &p) {
        std::cout << "拷贝构造函数" << std::endl;
        m_age = p.m_age;
//        m_height = p.m_height;//编译器进行浅拷贝的操作,如果做的是这种操作,会导致新的对象和旧的对象的m_height都是同一个指针,而这两个指针指向同一块内存地址  
//,对象进行析构时,无论是新或者旧对象进行析构,都会将m_height指向内存释放,而另一个对象进行析构时,会导致内存的重复释放,导致错误  
//因此进行深拷贝操作,在调用拷贝构造函数时,在堆区新建一块内存使得m_height的值是m_height但是是另外一个指针了,从而避免了浅拷贝带来的内存重复释放问题
        //深拷贝操作
        m_height = new int(*p.m_height);
    }

    ~Person() {
        //将堆区开辟的数据做释放操作
        //使用浅拷贝会导致堆区内存重复释放报错
        if (m_height != NULL) {
            delete m_height;
            m_height = NULL;
        }
        std::cout << "析构函数" << std::endl;
    }

    int m_age;//int类型的属性
    int *m_height;//int指针类型的属性
};

void test01() {
    Person p1(18, 160);
    std::cout << "p1的年龄：" << p1.m_age << "  身高为:" << *p1.m_height << std::endl;
    Person p2(p1);
    std::cout << "p2的年龄：" << p2.m_age << "  身高为:" << *p2.m_height << std::endl;
}

int main() {
    test01();
    return 0;
}


总的来说,深拷贝和浅拷贝的区别在于是否开辟了新空间用于接收传入对象的指针属性,如果还是简单地直接赋值,则就是浅拷贝(在属性不是指针时不会有内存重复释放问题),否则就是深拷贝.
```

### 类对象作为类的成员
类对象可以作为类的成员
C++类中的成员可以是另一个类的对象,我们称该对象为对象成员,例如:
```
class A{}
class B{ A a; }
B类中有对象a作为B的成员
```
当其他类对象作为本类成员,构造时候先构造其他类对象,再构造自身;先析构自身,再析构类对象;类似于其他类对象在更外层的感觉.

### 静态成员
静态成员就是在成员变量和成员函数前加上关键字static,称为静态成员
静态成员分为
* 静态成员变量
* 静态成员函数
```
静态成员变量--所有对象共享一份数据;在编译阶段分配内存;类捏声明,类外初始化
静态成员函数--所有对象共享同一个函数;静态成员函数只能访问静态成员变量 
```
访问静态函数的方法有两种:
```
通过对象访问(其他非静态函数的调用方式也适用于静态函数)
Person p;
p.func();
```
```
通过类名进行访问(仅静态函数可以通过这种方式访问,归根究底,因为静态成员函数所有对象都共享一份,静态方法中的属性必须都是静态的,也就是不区分与对象的,  
即所有对象调用该静态函数的结果都是一样的,  
那么前一种的用对象来区分函数执行的方式其实是可以省略的--反正所有对象都一样,  
那我直接指定类名来调用该方法不都是一样的嘛,毕竟所有对象都是这个类的实例化)
Person::func();
当然的,即使是静态函数,只要是private的,那类外就无法访问了
```

### C++对象模型
在C++中,类内的成员变量和成员函数分开存储,只有非静态成员才属于类的对象上
```
class Person{
    int m_A;//非静态成员,属于类的对象上
    static int m_B;//静态成员,不属于类的对象上,也不占用对象的空间
    void func(){}//非静态成员函数同样不属于类对象上
    static void func1(){}//静态成员函数也不属于类的对象上
}
```

空对象占用的空间为1,C++编译器会给每个空对象也分配一个字节空间,是为了区分空对象占内存的位置,每个空对象也应该有一个独一无二的内存地址

### this指针
C++中成员变量和成员函数是分开存储的,每一个非静态成员函数只会产生一份函数实例,也就是多个同类型对象会共用一块代码
一块代码如何区分不同的对象?
C++通过提供特殊的对象指针this指针来解决这个问题,this指针指向了被调用的成员函数所属的对象
```
this指针是隐含每一个非静态成员函数内的一种指针
this指针不需要定义,直接使用即可
```
this指针的用途
* 当形参和成员变量同名时,可以用this指针进行区分
* 在类的非静态成员函数中返回对象本身,可以使用return *this;

### 空指针访问成员函数
C++中空指针也可以调用成员函数,但是也要注意有没有用到this指针,如果用到this指针,则需要加以判断来保证代码的健壮性
```
class Person{
    public:
     showClassName(){std::cout<<""<<std::endl;}
     showPersonName(){
         if(this==NULL){return;}//添加空指针判断
         std::cout<<age<<std::endl;//如果不加判断,会导致报错,age==this.age,不能访问空指针属性
         int age;
     }
}
```

### const修饰成员函数
常函数:
* 成员函数后加const后称这个函数为常函数
* 常函数内不可以修改成员变量
* 成员函数声明时加关键字mutable后,在常函数中仍然可以修改  
  
常对象:
* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数
```
this指针的本质是指针常量,其指向不可以修改,即 className * const this;
而在函数名后添加const则变为了const className * const this;
成为了const既修饰指针也修饰常量,则this的指向和值都不可以修改了

class Base{
    public:
    Base(){}
    void func() const {
        //this->m_A=10;//不可以修改值了
        this->m_B=10;//由于mutable修饰仍然可以修改值
    }
    int m_A;
    mutable int m_B;//使用mutable修饰成员属性,则在常函数中也可以修改其值
}

void test(){
    const Base p;//在对象前加const,将对象变为了常对象,需要在类中手动添加一个默认构造函数来完成const类型对象的初始化,不手动添加构造函数会报语法错

    //p.m_A=10;//常对象不可修改非mutable修饰的成员属性
    p.m_B=10;//常对象只能修改mutable修饰的成员属性
    p.func();//常对象只能调用常函数，而不能调用普通函数
    //因为普通函数内的普通成员属性是可以修改其值的，而常对象不能修改不加mutable的对象属性，为避免这种操作，常对象只能调用常函数
}
```

### 友元
在程序内，有一些私有属性也想要让类外的一些特殊的函数或类进行访问，就需要用到友元的技术。元友的目的就是让一个函数或者类访问而另一个类中的私有成员
```
友元的关键字是friend
```
友元的三种实现
* 全局函数做友元
* 类做友元
* 成员函数做友元

### 运算符重载

