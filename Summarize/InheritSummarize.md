## 继承
### 概述
继承是面向对象三大特性之一  
有些类与类之间存在特殊的关系，定义某些类时，下级别的成员除了拥有上一级的共性，还有自己的特性，这个时候可以考虑利用继承的技术，减少代码量  
```
优点：减少肩负的代码
语法： class 子类 : 继承方式 父类{}
子类又被称为派生类，父类又被称为基类
子类中的成员，包含两大部分：
一类是从基类继承过来的，一类是自己增加的成员
从基类继承过来的表现其共性，而新增的成员体现了其个性
```
### 继承方式
继承的方式一共有三种：
* 公共继承
* 保护继承
* 私有继承
  
<a href="https://imgbb.com/"><img src="https://i.ibb.co/h7mb9BT/drawio-2.png" alt="drawio-2" border="0"></a><br /><a target='_blank' href='https://geojsonlint.com/'></a><br />

### 继承中的对象模型
从父类继承过来的成员，哪些属于子类对象中？
子类中继承父类中的所有非静态对象，无论继承方式是public/protected/private
则子类中的对象=父类中的非静态对象+子类新创建的非静态对象
实际上父类中的静态对象本来也不属于父类中的对象上，更谈不上继承了

### 继承中的构造和析构
子类继承父类后，当创建子类对象，也会调用父类中的构造函数。  
其构造和析构的顺序为：父类构造-> 子类构造->子类析构->父类析构
其顺序类似于类中有其他类的对象作为类的成员属性，其构造和析构顺序为：其他类构造->本类构造->本类析构->其他类析构
就是说其他类和父类都是在更外层，因此产生了这种构造和析构顺序：
外构造->内构造->内析构->外析构

### 继承中的同名成员
当基类和派生类中出现同名的成员，通过子类的对象如何区分这些对象并进行访问？
```
访问子类同名成员，直接通过子类对象进行访问即可
访问父类同名成员，需要加父类作用域

class Base{
    public:
    int m_A;
    static int m_B;
    void func(){}
    static void func(int num){}
}
Base::m_B=100;//通过加作用域来访问父类的同名静态成员
class Son:public Base{
    public:
    int m_A;
    static int m_B;
    void func(){}
}
Son::m_A=100;//通过加作用域来访问子类的同名静态成员
void main(){
    Son s;
    s.m_A=10;//访问子类的同名成员
    s.Base::m_B=10;//访问父类中的同名成员
    s.func();//调用子类中的同名函数
    s.Base::func();//调用父类中的同名函数

    Son::func();//通过作用域调用子类中的无参静态寒素
    Son::Base::func(10);//通过作用域来调用父类中的有参静态函数
    Son::func(10);//但是不能用这种方式调用父类的有参静态函数了，因为所有同名的父类函数（无论重载形式如何）都被子类同名函数覆盖了
}
```
### 多继承
C++允许一个类继承多个类
```
语法：class 子类：继承方式 父类1，继承方式 父类2，...{}
多继承可能引起父类中同名函数的问题，需要添加不同的父类作用域来做区分
```
C++ 实际开发中不建议使用多继承

### 钻石（菱形）继承
菱形继承概念：  
两个派生类继承同一个基类，又有某个类同时继承两个派生类
```
当产生菱形继承时，最末端的类继承了两个首端父类的数据，需要加以作用域做区分。  
但其实，两份数据不是必要的，导致了资源浪费，可以使用virtual虚继承来解决这个问题  
使用虚继承后，不再是继承两份数据，而是继承两个指针，两个指针可以通过偏移量找到唯一的数据
class Animal{
    public:
    int num;
}
class Sheep:virtual public Animal{

}
class Tuo:virtual public Animal{

}
class SheepTuo: public Sheep,Public Tuo{

}

void test(){
    SheepTuo p;
    //若不使用虚继承，则需要添加作用域来区分两个父类的num成员
    p.Sheep::num=10;//访问Sheep父类的成员
    p.Tuo::num=10;//访问Tuo父类的成员
    p.Animal::num=10;//访问首端父类Animal的成员
    p.num=10;//在不添加虚继承关键字的情况下，这种赋值方式是报语法错误的
    //也就是说，末端的num属性是Sheep类和Tuo类继承过来的，直接使用对象赋值而不加作用域是无法区分这个num究竟是属于哪个父类的，  
    //但是添加virtual关键字后就可以使用虚继承得到的两个指针来唯一的区分了
}
```